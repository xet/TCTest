
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.w3c.dom.Document;
import org.w3c.dom.DOMException;


import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
/**
 * 
 * @author Per Engstroem <xetkexet at gmail dot com>
 * @date 2012-07-26
 * 
 * The BOMXMLHandler is used for creating and parsing an XML document with a XSLT template.
 *
 */

public class BOMXMLHandler {
		// globals
	
    private static ByteArrayOutputStream xmldata;
    private static ByteArrayOutputStream resultStream;
    private static File stylesheet;
    /**
     * Writes data to buffert.
     * @param 	data				Data to write into buffer.
     * @throws	IOException	In and out exception.
     */
    public void writeToBuff(String data) throws IOException {
    	byte buf[] = data.getBytes("UTF-8"); // UTF-8 Allows Swedish characters :)
    	xmldata.write(buf);
    }
    /**
     * Dfine xsl stylesheet to use.
     * @param		name				Filename Of stylesheet.
     */
    public void defineStyleSheet(String filename) {
    	stylesheet = new File(filename);
    }
    /**
     * Initialize BOMXMLHandler.
     */
    public BOMXMLHandler () {
    	// Create a ByteArrayOutputStream to store XML-data
			xmldata = new ByteArrayOutputStream();
    }
    /**
     * Converts a OutputStream to an InputStream.
     * @param		outputStream	OutputStream to convert.
     * @return								OutputStream converted to InputStream.
     */
    private ByteArrayInputStream convertToInputStream(ByteArrayOutputStream outputStream) {
      ByteArrayInputStream datafile = new ByteArrayInputStream(outputStream.toByteArray());
      return datafile;
    }
    /**
     * Transform XML (from buffer) with XSLT(defined with defineStyleSheet)
     */
    public void transformXMLWithXSL() {
    	try {
    		// Convert the private OuputStream xmldata to an InputStream
    		ByteArrayInputStream datafile = convertToInputStream(this.xmldata);
    		// Create a new a new Instance of a Do
    		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    		//Create a DocumentBuilder
    		DocumentBuilder builder = factory.newDocumentBuilder();
    		// let the builder parse datafile into a document
    		Document document = builder.parse(datafile);
    		// Use a Transformer for output, start with creating a TransformerFactory
    		TransformerFactory tFactory = TransformerFactory.newInstance();
    		// We also need a stylesheetsource
    		StreamSource stylesource = new StreamSource(stylesheet);
    		// Now we create a transformer of the stylesource
    		Transformer transformer = tFactory.newTransformer(stylesource);
    	
    		DOMSource source = new DOMSource(document);
    		
    		resultStream = new ByteArrayOutputStream();
    		StreamResult result = new StreamResult(resultStream);
    	
    		transformer.transform(source, result);
    	}
    	catch (FactoryConfigurationError fce) {
    		//- if the implementation is not available or cannot be instantiated.
    	}
    	catch (TransformerConfigurationException tce) {
    		// Error generated by the parser
    		//TransformerFactoryConfigurationError - if the implmentation is not available or cannot be instantiated.
    		/*
    		System.out.println("\n** Transformer Factory error");
    		System.out.println("   " + tce.getMessage());

    		// Use the contained exception, if any
    		Throwable x = tce;

    		if (tce.getException() != null) {
        	x = tce.getException();
    		}
				x.printStackTrace();
				*/
    	}
    	catch (TransformerException te) {
    	//	TransformerException - If an unrecoverable error occurs during the course of the transformation.

    		// Error generated by the parser
    		/*
    		System.out.println("\n** Transformation error");
    		System.out.println("   " + te.getMessage());

    		// Use the contained exception, if any
    		Throwable x = te;

    		if (te.getException() != null) {
        	x = te.getException();
    		}
		
		    x.printStackTrace();
		    */
    	}
    	catch (SAXException sxe) {
    		// If any parse errors occur.
    		System.out.println("Parse error!");
    		/*
    		Exception x = sxe;

    		if (sxe.getException() != null) {
  	     x = sxe.getException();
    	}

    	x.printStackTrace();
    	*/
    	}
    	catch (ParserConfigurationException pce) {
    		// Parser with specified options can't be built
    		// pce.printStackTrace();
    	}
			catch (IOException e) {
				// TODO Auto-generated catch block
				System.out.println("KOKO: IOException in transformWithXSL();");
				e.printStackTrace();
			}
    }
    /**
     * Returns the OutputStream.
     * @return 		The OutputStream
     */
		public ByteArrayOutputStream getOutputStream() {
			return resultStream;
		}
}
